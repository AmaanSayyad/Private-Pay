import {expect} from "chai";
import {ethers} from "hardhat";

import path from "path";

const SNARK_SCALAR_FIELD =
  21888242871839275222246405745257275088548364400416034343698204186575808495617n;

function modField(x: bigint): bigint {
  const r = x % SNARK_SCALAR_FIELD;
  return r >= 0n ? r : r + SNARK_SCALAR_FIELD;
}

describe("AxelarPrivacyPool (fixed denom)", function () {
  it("deposits then withdraws+bridges via pool sender", async function () {
    const snarkjs = require("snarkjs");
    const {buildMimcSponge, mimcSpongecontract} = require("circomlibjs");

    const [depositorA, depositorB, relayer] = await ethers.getSigners();
    const destinationChain = "polygon-sepolia";

    const mimc = await buildMimcSponge();
    const F = mimc.F;
    const hash2 = (a: bigint, b: bigint): bigint =>
      BigInt(F.toObject(mimc.hash(a, b, 0).xL) as unknown as bigint);

    const TREE_LEVELS = 20;
    const zeros: bigint[] = [];
    zeros[0] = hash2(0n, 0n);
    for (let i = 1; i < TREE_LEVELS; i++) zeros[i] = hash2(zeros[i - 1], zeros[i - 1]);

    const denom = ethers.parseUnits("10", 6);

    const MockERC20 = await ethers.getContractFactory("MockERC20");
    const token = await MockERC20.deploy("Mock USDC", "mUSDC", 6);
    await token.waitForDeployment();

    await token.mint(await depositorA.getAddress(), denom);
    await token.mint(await depositorB.getAddress(), denom);

    // Deploy MiMC sponge hasher (bytecode generated by circomlibjs)
    // This matches circomlib's `mimcsponge.circom` (Fr field).
    const hasherBytecode = mimcSpongecontract.createCode("mimcsponge", 220);
    const HasherFactory = new ethers.ContractFactory(mimcSpongecontract.abi, hasherBytecode, depositorA);
    const hasher = await HasherFactory.deploy();
    await hasher.waitForDeployment();
    const onchain00 = await hasher.MiMCSponge(0, 0, 0);
    expect(BigInt(onchain00[0])).to.equal(zeros[0]);

    const Groth16Verifier = await ethers.getContractFactory("Groth16Verifier");
    const verifier = await Groth16Verifier.deploy();
    await verifier.waitForDeployment();

    const itsTokenId = ethers.keccak256(ethers.toUtf8Bytes("ITS_TOKEN_ID"));

    const MockInterchainTokenService = await ethers.getContractFactory("MockInterchainTokenService");
    const its = await MockInterchainTokenService.deploy();
    await its.waitForDeployment();
    await its.setToken(itsTokenId, await token.getAddress());

    const AxelarStealthBridge = await ethers.getContractFactory("AxelarStealthBridge");
    const bridge = await AxelarStealthBridge.deploy(
      await depositorA.getAddress(), // gateway (unused in this test)
      await depositorA.getAddress(), // gas service (unused in ITS flow)
      await its.getAddress(), // token service (used)
      await depositorA.getAddress()
    );
    await bridge.waitForDeployment();
    await bridge.setProtocolFee(0);
    await bridge.setTrustedRemote(destinationChain, await bridge.getAddress());

    const AxelarPrivacyPool = await ethers.getContractFactory("AxelarPrivacyPool");
    const pool = await AxelarPrivacyPool.deploy(
      await token.getAddress(),
      denom,
      await hasher.getAddress(),
      await bridge.getAddress(),
      itsTokenId,
      "",
      await verifier.getAddress()
    );
    await pool.waitForDeployment();

    const nullifierA = modField(123456789n);
    const secretA = modField(987654321n);
    const commitmentA = hash2(nullifierA, secretA);

    const nullifierB = modField(2222222n);
    const secretB = modField(3333333n);
    const commitmentB = hash2(nullifierB, secretB);

    const leaves: bigint[] = [commitmentA, commitmentB];

    await token.connect(depositorA).approve(await pool.getAddress(), denom);
    await token.connect(depositorB).approve(await pool.getAddress(), denom);

    await pool.connect(depositorA).deposit(commitmentA);
    await pool.connect(depositorB).deposit(commitmentB);

    const rootOnchain = BigInt(await pool.getLastRoot());

    // For the 2-leaf case, leaf(0) has a simple path:
    // level 0 sibling = leaf(1), higher siblings are the precomputed zeros.
    const pathElements: bigint[] = [];
    const pathIndices: number[] = [];
    pathElements[0] = commitmentB;
    pathIndices[0] = 0;
    for (let level = 1; level < TREE_LEVELS; level++) {
      pathElements[level] = zeros[level];
      pathIndices[level] = 0;
    }

    // Recompute root from leaf(0) + its path using the same left/right convention as the circuit.
    let cur = commitmentA;
    for (let level = 0; level < TREE_LEVELS; level++) {
      cur = hash2(cur, pathElements[level]);
    }
    expect(cur).to.equal(rootOnchain);

    const nullifierHash = hash2(nullifierA, 0n);

    const stealthAddress = await depositorA.getAddress();
    const ephemeralPubKey = "0x" + "11".repeat(33);
    const viewHint = "0x22";
    const k = 0;
    const relayerFee = ethers.parseUnits("1", 6);
    const amountToBridge = denom - relayerFee;

    const packed = ethers.solidityPacked(
      ["string", "address", "bytes", "bytes1", "uint32", "uint256", "uint256", "address", "bytes32"],
      [
        destinationChain,
        stealthAddress,
        ephemeralPubKey,
        viewHint,
        k,
        amountToBridge,
        relayerFee,
        await bridge.getAddress(),
        itsTokenId,
      ]
    );
    const extDataHash = modField(BigInt(ethers.keccak256(packed)));

    const wasmPath = path.resolve(
      __dirname,
      "..",
      "circuits",
      "axelar-pool",
      "build",
      "WithdrawAndBridge_js",
      "WithdrawAndBridge.wasm"
    );
    const zkeyPath = path.resolve(
      __dirname,
      "..",
      "circuits",
      "axelar-pool",
      "build",
      "WithdrawAndBridge_final.zkey"
    );

    const input = {
      root: rootOnchain.toString(),
      nullifierHash: nullifierHash.toString(),
      extDataHash: extDataHash.toString(),
      nullifier: nullifierA.toString(),
      secret: secretA.toString(),
      pathElements: pathElements.map((x) => x.toString()),
      pathIndices: pathIndices.map((x) => x.toString()),
    };

    const {proof, publicSignals} = await snarkjs.groth16.fullProve(input, wasmPath, zkeyPath);
    const callData = await snarkjs.groth16.exportSolidityCallData(proof, publicSignals);
    const [a, b, c, inputs] = JSON.parse(`[${callData}]`);

    expect(BigInt(inputs[0])).to.equal(rootOnchain);
    expect(BigInt(inputs[1])).to.equal(nullifierHash);
    expect(BigInt(inputs[2])).to.equal(extDataHash);

    const relayerAddress = await relayer.getAddress();
    const relayerBalBefore = await token.balanceOf(relayerAddress);
    const itsBalBefore = await token.balanceOf(await its.getAddress());

    await expect(
      pool
        .connect(relayer)
        .withdrawAndBridgeITS(
          rootOnchain,
          nullifierHash,
          relayerFee,
          destinationChain,
          stealthAddress,
          ephemeralPubKey,
          viewHint,
          k,
          a,
          b,
          c,
          {value: 1}
        )
    )
      .to.emit(pool, "WithdrawalAndBridge")
      .withArgs(nullifierHash, relayerAddress, destinationChain, stealthAddress, amountToBridge, relayerFee);

    expect(await pool.nullifierHashes(nullifierHash)).to.equal(true);

    const relayerBalAfter = await token.balanceOf(relayerAddress);
    const itsBalAfter = await token.balanceOf(await its.getAddress());

    expect(relayerBalAfter - relayerBalBefore).to.equal(relayerFee);
    expect(itsBalAfter - itsBalBefore).to.equal(amountToBridge);
  }).timeout(600000);
});
